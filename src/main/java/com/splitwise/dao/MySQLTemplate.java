package com.splitwise.dao;

import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.sql.DataSource;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.splitwise.exception.CustomException;
import com.splitwise.modal.common.Persistable;
import com.splitwise.modal.common.ReflectionCommon;

@Component
public class MySQLTemplate extends ReflectionCommon {

	private DataSource datasource;
	private Connection connection;
	private PreparedStatement ps;

	private static final Logger LOG = Logger.getLogger(MySQLTemplate.class);

	@Autowired
	public MySQLTemplate(DataSource dataSource) {
		try {
			LOG.info(dataSource);
			this.datasource = dataSource;
			this.connection = datasource.getConnection();
			LOG.info(connection);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public <T extends Persistable> boolean createTableIfNotExist(String tableName, Class<T> entityClass) {

		LOG.info("Entered into createTableIfNotExist method");
		StringBuffer sb = new StringBuffer("CREATE TABLE IF NOT EXISTS " + tableName + " (");
		boolean insertSuccess = false;
		Statement stmt = null;
		try {
			List<Field> fields = getFields(entityClass);
			for (Field field : fields) {
				sb.append(field.getName() + " " + switchCase(field.getType().getName() + ", "));
			}
			sb = sb.deleteCharAt(sb.length() - 2);
			sb.append(");");
			LOG.info(sb);
			stmt = connection.createStatement();
			stmt.executeUpdate(sb.toString());
			insertSuccess = true;
			LOG.info("------Successfully created table with " + tableName);
		} catch (CustomException | SQLException | IllegalArgumentException e) {
			e.printStackTrace();
			insertSuccess = false;
		} finally {
			try {
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		LOG.info("exit from createTableIfNotExist method");
		return insertSuccess;
	}

	/**
	 * <p>
	 * Used to create table with primary key with auto generated if
	 * isAutoGeneratedField is true.
	 * </p>
	 * 
	 * @param <T>
	 * @param t
	 * @param tableName
	 * @param entityClass
	 * @return boolean
	 * @author Aviral
	 * 
	 */
	public <T extends Persistable> boolean createTableWithPKAutoGeneratedIfNotExist(T t, String tableName,
			Class<T> entityClass) {

		LOG.info("Entered into createTableWithPKAutoGeneratedIfNotExist method");
		StringBuffer sb = new StringBuffer("CREATE TABLE IF NOT EXISTS " + tableName + " (");
		boolean insertSuccess = false;
		Statement stmt = null;
		try {
			List<Field> fields = getFields(entityClass);
			for (Field field : fields) {
				if (t.isAutoGeneratedField() && field.getName().equals(t.getPrimaryKeyField())) {
					sb.append(t.getPrimaryKeyField() + " " + switchCase(field.getType().getName())
							+ " NOT NULL AUTO_INCREMENT,");
				} else {
					if (!field.getType().getName().contains("List")) {
						sb.append(field.getName() + " " + switchCase(field.getType().getName()) + ", ");
					}
				}
			}
			sb.append(" PRIMARY KEY (" + t.getPrimaryKeyField() + "));");
			LOG.info(sb);
			stmt = connection.createStatement();
			stmt.executeUpdate(sb.toString());
			insertSuccess = true;
			LOG.info("------Successfully created table with " + tableName);
		} catch (Exception e) {
			e.printStackTrace();
			insertSuccess = false;
		} finally {
			try {
				if (stmt != null) {
					stmt.close();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		LOG.info("exit from createTableIfNotExist method");
		return insertSuccess;
	}

	private String switchCase(String type) throws CustomException {

		if (type.contains("String")) {
			return "VARCHAR(45)";
		} else if (type.contains("Integer")) {
			return "INT";
		} else if (type.contains("Date")) {
			return "DATETIME";
		} else if (type.contains("Double")) {
			return "DECIMAL";
		} else if ((type.contains("boolean")) || (type.contains("Boolean"))) {
			return "BOOLEAN";
		} else {
			throw new CustomException("Specified Datatype: " + type + " not found.");
		}
	}

	public <T extends Persistable> boolean insertAll(List<T> listT, String tableName, Class<T> clazz) {

		boolean isInserted = false;
		LOG.info("::: Entered into insertAll method :::");
		isInserted = insertBatch(listT, tableName, clazz);
		LOG.info("::: Exiting from insertAll method :::");
		return isInserted;
	}

	public <T extends Persistable> boolean insertBatch(List<T> listOfT, String tableName, Class<T> entityClass) {

		LOG.info("::: Entered into insertBatch method :::");
		try {
			List<Field> fields = getFields(entityClass);
			String str = getQuery(listOfT.get(0), tableName, entityClass, fields);
			ps = connection.prepareStatement(str);
			for (T t : listOfT) {
				List<Object> listOfValues = getFieldValues(t, fields);
				int j = 1;
				for (int i = 0; i < listOfValues.size(); i++) {
					ps.setObject(j, listOfValues.get(i));
					j++;
				}
				ps.addBatch();
				LOG.info("::: Object added into batch :::");
			}
			int[] res = ps.executeBatch();
			if (res.length > 0 && res.length == listOfT.size()) {
				System.out.println(res.length);
				return true;
			}
			ps.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		LOG.info("::: Exiting from insertBatch method :::");
		return false;
	}

	public <T extends Persistable> boolean insert(T t, String tableName, Class<T> entityClass) {

		LOG.info("Entered into insert method");
		boolean isInsert = false;
		List<Field> fields = getFields(entityClass);
		List<Object> listOfValues = new ArrayList<>();
		String query = prepareInsertQuery(t, tableName, entityClass, fields, listOfValues);
		try {
			ps = connection.prepareStatement(query);
			int j = 1;
			for (int i = 0; i < listOfValues.size(); i++) {
				ps.setObject(j, listOfValues.get(i));
				j++;
			}
			int i = ps.executeUpdate();
			if (i > 0) {
				isInsert = true;
				LOG.info(isInsert);
				LOG.info("Successfully inserted record in table " + tableName);
			}
		} catch (IllegalArgumentException | SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				ps.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		LOG.info("exit from insert method");
		return isInsert;
	}

	public <T extends Persistable> Integer insertAndGetAutoGeneratedKey(T t, String tableName, Class<T> entityClass) {

		boolean isInsert = false;
		List<Field> fields = getFields(entityClass);
		List<Object> listOfValues = new ArrayList<>();
		String query = prepareInsertQuery(t, tableName, entityClass, fields, listOfValues);
		try {
			ps = connection.prepareStatement(query, Statement.RETURN_GENERATED_KEYS);
			int j = 1;
			for (int i = 0; i < listOfValues.size(); i++) {
				ps.setObject(j, listOfValues.get(i));
				j++;
			}
			int i = ps.executeUpdate();
			if (i > 0) {
				isInsert = true;
				LOG.info(isInsert);
				LOG.info("Successfully inserted record in table " + tableName);
				return i;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				ps.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		LOG.info("exit from insert method");
		return -1;
	}

	private <T> String prepareInsertQuery(T t, String tableName, Class<T> entityClass, List<Field> fields,
			List<Object> listOfValues) {

		LOG.info("Entered into insert method");
		StringBuilder sb = new StringBuilder("INSERT INTO " + tableName + " (");
		try {
			for (Field field : fields) {
				Object value = field.get(t);
				if (value != null && !field.getType().getName().contains("List")) {
					sb.append(field.getName() + ",");
					listOfValues.add(value);
				}
			}
			sb = sb.deleteCharAt(sb.length() - 1);
			sb.append(") VALUES (");
			for (int i = 1; i <= listOfValues.size(); i++) {
				sb.append("?,");
			}
			sb = sb.deleteCharAt(sb.length() - 1);
			sb.append(");");
			LOG.info(sb);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return sb.toString();
	}

	public <T extends Persistable> List<T> getAllRecords(String table, Class<T> entityClass) {

		LOG.info("getAllRecords method called....");
		String query = "SELECT * FROM " + table + ";";
		LOG.info(query);
		List<T> queryResults = new ArrayList<>();
		Map<String, Field> fieldsMap = getFieldsMap(entityClass);
		ResultSet rs = null;
		try {
			Statement stmt = connection.createStatement();
			rs = stmt.executeQuery(query);
			getAllRecords(rs, fieldsMap, queryResults, entityClass);
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		LOG.info("exit from getAllRecords method....");
		return queryResults;
	}

	public <T extends Persistable> List<T> getAllRecordsByID(T t, String table, Class<T> entityClass) {

		LOG.info("getAllRecords method called....");
		String query = "SELECT * FROM " + table + " ";
		Map<String, Object> map = getFieldsWithValueMap(t, entityClass);
		for (Entry<String, Object> entry : map.entrySet()) {
			if (entry.getValue() instanceof Integer
					&& Integer.valueOf(entry.getValue().toString()) == t.getGroup_id()) {
				query = query + "where " + entry.getKey() + " = " + entry.getValue() + ";";
				break;
			}
		}
		LOG.info(query);
		List<T> queryResults = new ArrayList<>();
		Map<String, Field> fieldsMap = getFieldsMap(entityClass);
		ResultSet rs = null;
		try {
			Statement stmt = connection.createStatement();
			rs = stmt.executeQuery(query);
			getAllRecords(rs, fieldsMap, queryResults, entityClass);
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		LOG.info("exit from getAllRecords method....");
		return queryResults;
	}

	public <T extends Persistable> T getRecordOnBasisOfId(T t, Object primaryKeyValue, String table,
			Class<T> entityClass) {

		LOG.info("getRecord method called....");
		// String primaryKey = GET_PRIMARY_KEY_MAP.get(entityClass);
		StringBuilder sb = new StringBuilder("SELECT * FROM " + table + " where " + t.getPrimaryKeyField() + " = ? ;");
		LOG.info(sb);
		ResultSet rs = null;
		Map<String, Field> fieldsMap = getFieldsMap(entityClass);
		try {
			ps = connection.prepareStatement(sb.toString());
			ps.setObject(1, primaryKeyValue);
			rs = ps.executeQuery();
			while (rs.next()) {
				return getRecord(entityClass, fieldsMap, rs);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				ps.close();
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		T ts = null;
		try {
			ts = entityClass.newInstance();
		} catch (InstantiationException | IllegalAccessException e) {
			e.printStackTrace();
		}
		return ts;
	}

	public <T extends Persistable> boolean updateRecord(T t, String tableName, Class<T> entityClass) {

		Map<String, Object> getFieldsWithValueMap = getFieldsWithValueMap(t, entityClass);
		if (getFieldsWithValueMap.isEmpty()) {
			return true;
		} else {
			StringBuffer sb = new StringBuffer("update " + tableName + " set ");
			for (Entry<String, Object> fieldWithValueEntry : getFieldsWithValueMap.entrySet()) {
				if (fieldWithValueEntry.getKey().equals(t.getPrimaryKeyField())) {
					continue;
				} else {
					if (fieldWithValueEntry.getValue() instanceof String) {
						sb.append(fieldWithValueEntry.getKey() + " = '" + fieldWithValueEntry.getValue() + "', ");
					} else {
						sb.append(fieldWithValueEntry.getKey() + " = " + fieldWithValueEntry.getValue() + ", ");
					}
				}
			}
			String updateQuery = sb.substring(0, sb.length() - 2);
			List<Field> fields = getFields(entityClass);
			Object value = null;
			for (Field field : fields) {
				try {
					value = field.get(t);
					if (value != null && field.getName().equals(t.getPrimaryKeyField())) {
						if (value instanceof String) {
							updateQuery = updateQuery + " where " + t.getPrimaryKeyField() + " = '" + value + "'";
						} else {
							updateQuery = updateQuery + " where " + t.getPrimaryKeyField() + " = " + value;
						}
						break;
					}
				} catch (IllegalArgumentException | IllegalAccessException e) {
					e.printStackTrace();
				}
			}
			LOG.info("Query: " + updateQuery);
			try {
				ps = connection.prepareStatement(updateQuery);
				int executed = ps.executeUpdate();
				if (executed > 0) {
					LOG.info("Successfully executed update query on table: " + tableName);
					return true;
				}
			} catch (SQLException e) {
				e.printStackTrace();
			} finally {
				try {
					ps.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			return false;
		}
	}
}
